#include "_doctype.html"
<HTML>
<HEAD>
<TITLE>Curl::easy - Perl extension for libcurl</TITLE>
</HEAD>
 
#define LIBCURL_PERL
 
#include "_menu.html"
#include "setup.t"
#include "download.t"
 
WHERE2(libcurl, "/libcurl/", Perl Interface)
 
<a name=top>
TITLE(Curl::easy -- accessing libcurl from perl)
<UL>

	<LI><A HREF="#NAME">NAME</A>
	<LI><A HREF="#SYNOPSIS">SYNOPSIS</A>
	<LI><A HREF="#DESCRIPTION">DESCRIPTION </A>
	<UL>

		<LI><A HREF="#FILES_and_CALLBACKS">FILES and CALLBACKS</A>
		<LI><A HREF="#FILE_handles_GLOBS_">FILE handles (GLOBS)</A>
		<LI><A HREF="#WRITE_callback">WRITE callback</A>
		<LI><A HREF="#READ_callback">READ callback</A>
		<LI><A HREF="#PROGRESS_callback">PROGRESS callback</A>
		<LI><A HREF="#PASSWD_callback">PASSWD callback</A>
	</UL>

	<LI><A HREF="#AUTHOR">AUTHOR</A>
	<LI><A HREF="#Copyright">Copyright</A>
	<LI><A HREF="#SEE_ALSO">SEE ALSO</A>
</UL>
<!-- INDEX END -->

<HR>
<P>
<HR>
<H1><A NAME="NAME">NAME</A></H1>
<P>
Curl::easy - Perl extension for libcurl

<P>
<HR>
<H1><A NAME="SYNOPSIS">SYNOPSIS</A></H1>
<P>
<PRE>        use Curl::easy;
 
        $curl = Curl::easy::init();
        $CURLcode = Curl::easy::setopt($curl, CURLoption, Value);
        $CURLcode = Curl::easy::perform($curl);
        Curl::easy::cleanup($curl);
</PRE>
<P>
<PRE>        Read curl_easy_setopt for details of most CURLoption values
</PRE>
<P>
<HR>
<H1><A NAME="DESCRIPTION">DESCRIPTION</A></H1>
<P>
<PRE> 
B&lt;Curl::easy&gt; provides an interface to the libcurl C library. See
<A HREF="http://curl.haxx.se/">http://curl.haxx.se/</A> for more information on cURL and libcurl.
</PRE>
<P>
<HR>
<H2><A NAME="FILES_and_CALLBACKS">FILES and CALLBACKS</A></H2>
<P>
Curl::easy supports the various options of curl_easy_setopt which require
either a FILE * or a callback function.

<P>
The perl callback functions are handled through a C wrapper which takes
care of converting from C to perl variables and back again. This wrapper
simplifies some C arguments to make them behave in a more 'perl' like
manner. In particular, the read and write callbacks do not look just like
the 'fread' and 'fwrite' C functions - perl variables do not need separate
length parameters, and perl functions can return a list of variables,
instead of needing a pointer to modify. The details are described below.

<P>
<HR>
<H2><A NAME="FILE_handles_GLOBS_Curl_option">FILE handles (GLOBS)
 
Curl options which take a FILE, such as CURLOPT_FILE, CURLOPT_WRITEHEADER, CURLOPT_INFILE
can be passed a perl file handle:
 
  open BODY,&quot;&gt;body.out&quot;;
  $CURLcode = Curl::easy::setopt($curl, CURLOPT_FILE, BODY);</A></H2>
<P>
<HR>
<H2><A NAME="WRITE_callback">WRITE callback</A></H2>
<P>
The CUROPT_WRITEFUNCTION option may be set which will cause libcurl to
callback to the given subroutine:

<P>
<PRE>  sub chunk { my ($data,$pointer)=@_; ...; return length($data) }
  $CURLcode = Curl::easy::setopt($curl, CURLOPT_WRITEFUNCTION, \&amp;chunk );
  $CURLcode = Curl::easy::setopt($curl, CURLOPT_FILE, );
</PRE>
<P>
In this case, the subroutine will be passed whatever is defined by
CURLOPT_FILE. This can be a ref to a scalar, or a GLOB or anything else you
like.

<P>
The callback function must return the number of bytes 'handled' (
<CODE>length($data)</CODE> ) or the transfer will abort. A transfer can be
aborted by returning a 'length' of '-1'.

<P>
The option CURLOPT_WRITEHEADER can be set to pass a different '$pointer'
into the CURLOPT_WRITEFUNCTION for header values. This lets you collect the
headers and body separately:

<P>
<PRE>  my $headers=&quot;&quot;;
  my $body=&quot;&quot;;
  sub chunk { my ($data,$pointer)=@_; ${$pointer}.=$data; return length($data) }
</PRE>
<P>
<PRE>  $CURLcode = Curl::easy::setopt($curl, CURLOPT_WRITEFUNCTION, \&amp;chunk );
  $CURLcode = Curl::easy::setopt($curl, CURLOPT_WRITEHEADER, \$header );
  $CURLcode = Curl::easy::setopt($curl, CURLOPT_FILE, \$body );
</PRE>
<P>
If you have libcurl &gt; 7.7.1, then you could instead set
CURLOPT_HEADERFUNCTION to a different callback, and have the header
collected that way.

<P>
<HR>
<H2><A NAME="READ_callback">READ callback</A></H2>
<P>
Curl::easy supports CURLOPT_READFUNCTION. This function should look
something like this:

<P>
<PRE>    sub read_callback {
        my ($maxlength,$pointer)=@_;
</PRE>
<P>
<PRE>                ....
</PRE>
<P>
<PRE>        return $data;
    }
</PRE>
<P>
The subroutine must return an empty string ``'' at the end of the data.
Note that this function isn't told how much data to provide -
<CODE>$maxlength</CODE> is just the maximum size of the buffer provided by
libcurl. If you are doing an HTTP POST or PUT for example, it is important
that this function only returns as much data as the 'Content-Length' header
specifies, followed by a an empty (0 length) buffer.

<P>
<HR>
<H2><A NAME="PROGRESS_callback">PROGRESS callback</A></H2>
<P>
Curl::easy supports CURLOPT_PROGRESSFUNCTION. This function should look
something like this:

<P>
<PRE>    sub prog_callb
    {
        my ($clientp,$dltotal,$dlnow,$ultotal,$ulnow)=@_;
                ....
        return 0;
    }                        
</PRE>
<P>
The function should return 0 normally, or -1 which will abort/cancel the
transfer. <CODE>$clientp</CODE> is whatever value/scalar is set using the
CURLOPT_PROGRESSDATA option.

<P>
<HR>
<H2><A NAME="PASSWD_callback">PASSWD callback</A></H2>
<P>
Curl::easy supports CURLOPT_PASSWDFUNCTION. This function should look
something like this: sub passwd_callb { my ($clientp,$prompt,$buflen)=@_;
... return (0,$data); }                    

<P>
<CODE>$clientp</CODE> is whatever scalar is set using the
CURLOPT_PASSWDDATA option. <CODE>$prompt</CODE> is a text string which can
be used to prompt for a password. <CODE>$buflen</CODE> is the maximum
accepted password reply.

<P>
The function must return 0 (for 'OK') and the password data as a list.
Return (-1,``'') to indicate an error.

<P>
<HR>
<H1><A NAME="AUTHOR_Georg_Horn_horn_koblenz_">AUTHOR
 
Georg Horn &lt;horn@koblenz-net.de&gt;
 
Additional callback, pod and test work by Cris Bailiff &lt;c.bailiff@devsecure.com&gt;
and Forrest Cahoon &lt;forrest.cahoon@merrillcorp.com&gt;</A></H1>
<P>
Currently maintained by Cris Bailiff &lt;<A
HREF="mailto:c.bailiff@devsecure.com">c.bailiff@devsecure.com</A>&gt;

<P>
<HR>
<H1><A NAME="Copyright">Copyright</A></H1>
<P>
Copyright (C) 2000, Daniel Stenberg, , et al. You may opt to use, copy,
modify, merge, publish, distribute and/or sell copies of the Software, and
permit persons to whom the Software is furnished to do so, under the terms
of the MPL or the MIT/X-derivate licenses. You may pick one of these
licenses.

<P>
<HR>
<H1><A NAME="SEE_ALSO">SEE ALSO</A></H1>
<P>
<A HREF="http://curl.haxx.se/">http://curl.haxx.se/</A>
 
#include "_footer.html"
 
</BODY>
</HTML>
